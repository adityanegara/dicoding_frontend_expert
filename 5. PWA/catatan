A) Karakteristik Progresive Web Apps(PWA)

    A.1) Progresif
        : Bekerja untuk setiap pengguna. Tak peduli apapun browsernya, tidak masalah.
        PWA dibangun dengan peningkatan progresif sebagai intinya.

    A.2) Responsif
        : Mampu menyesuaikan dengan berbagai perangkat. Baik itu desktop, seluler, tablet, 
        atau yang lainnya.

    A.3) Konektivitas Independen
        : Service worker membantu mengikatkan proses load time ketika internet
        memiliki kualitas rendah, bahkan dapat diakses dalam keadaan offline.

    A.4) Seperti Aplikasi Native
        : Experience yang diberikan tak kalah dengan aplikasi native karena PWA dibangun dengan 
        struktur application shell.
    
    A.5) Aman
        : PWA mewajibkan web untuk berjalan pada HTTPS. ini tentu membuat web aman dari berbagai 
        ancaman

    A.6) Dapat Ditemukan
        : Terdefinisi sebagai "Aplikasi" berkat Web App Manifest dan service worker. 
        Dan dapat mudah ditemukan oleh search engine seperti Google.

    A.7) Re-engagable 
        : Dengan fitur pemberitahuan seperti push notification, dapat mengajak kembali
        pengguna untuk menggunakan aplikasi

    A.8) Dapat dipasang
        : Memungkinkan pengguna untuk memasang di layar beranda tanpa melalui application store

    A.9) Dapat ditautkan
        : Dapat dengan mudah dibagukan melalui URL.

B) Kelebihan PWA

    B.1) Tidak membutuhkan toko aplikasi
        : Karena PWA merupakan web, untuk menggunakannya cukup menggunakan browser saja

    B.2) Tidak perlu melakukan update
        : Cukup melakukan refresh layaknya web pada browser

    B.3) Mudah dipublikasi, diakses, dan dibagian
        : Cukup kirimkan tautan atau URL aplikasi dan pengguna lainnya bisa mengakses dengan cepat.

    B.4) Bisa memanfaatkan fitur native
        : notifikasi, lokasi, orientasi, gesture
    
    B.5) Mengurangi Penggunaan dapat
        : Load time PWA dapat lebih cepat dibandingkan dengan aplikasi native.

C) Kekurangan PWA

    C.1) Belum semua fitur native dapat dimanfaatkan PWA
        : kontak, SMS, Telepon, bluetooth, dan notification

    C.2) Tidak didukung browser lama

D) Komponen Pembentuk PWA

    D.1) Application shell
        : Kerangka antarmuka aplikasi. Mereka disimpan lebih dahulu di dalam cache sehingga
          dapat tampil secara instan saat aplikasi dibuka. Umumnya komponen halaman yang menjadi
          bagian dari app shell adalam komponen yang selalu ada untuk semua halaman 
          seperti header, sidebar, dan footer. Adapun komponen dari konten halamanakan dimuat
          secara dinamis dan asinkron.
    
    D.2) Web App Manifest
        : file JSON yang mengontrol bagaimana aplikasi ditampilkan dan dijalankan di sisi
          pengguna. 

    D.3) Service worker
        : Script yang dijalankan oleh browser di latar belakang. dengan menggunakan
        service worker, kita dapat memanfaatkan resource yang tersimpan di dalam cache
        untuk menampilkan konten bahkan dalam mode jaringan offline.

    D.4) Cache API 
        : Tempat penyimpanan lokall yang digunakan browser untuk menyimpan resource agar
        dapat digunakan kembali. 

    D.5) Fetch API
        : melakukan request pada server.

    D.6) IndexedDB
        : sistem penyimpanan lokal berbasis NoSQL di browser.

    D.7) Web Socket
        : untuk real time communication
    
    D.8) Notifications
        : notifikasi popun yang muncul pada perangkat.

E) Web Architecture

    : Ada dua arsitektur yang digunakan dalam membangun sebuah web bila ditinjau dari
      bagaimana server mengembalikan konten halaman, yakni Server side rendering(SSR) dan
      Client Side Rendering (CSR). 

      SSR : Pola dimana setiap halaman di render pada sisi server dan dikembalikan ke browser
            dalam bentuk HTML yang siap ditampilkan.

      CSR : Pola dimana server hanya mengembalikan data(biasanya dalam bentuk format JSON atau XML) 
            untuk olah dan di render pada sisi client (browser) oleh javascript

     Ada dua pola arsitektur web yang ditinjau dari bagaimana sebuah konten dimuat yaitu
     Single page app, dan multi-page app.

      MPA : saat website terdiri dari beberapa halaman HTML. seperti
            domain.com/home.HTML
            domain.com/profile.HTML
            domain.com/timeline.HTML
     
      SPA : website hanya menggunakan satu berkas HTML
            domain.com/#/home -> Halaman Home
            domain.com/#/profile -> Halaman Profil
            domain.com/#/timeline -> Halaman Timeline
            
F) Application shell

    : Salah satu teknik dalam PWA untuk membuat komponen UI termuat secara instan tanpa menunggu
      response dari server. App shell sejatinya hanya terdiri dari HTML, CSS, dan javascript
      yang disimpan dalam cache pada request pertama agar request selanjutnya tidak
      perlu mengambil dari server lagi.

G) Siklus Hidup Service Worker
   
    G.1) Installation
    :Karena Service Worker terpisah dari DOM, untuk menambahkan event kita bisa
    gunakan self, bukan window ataupun document. Umumnya pada proses ini
    kita melakukan penyimpanan resource App Shell pada Caches API.

    G.2) Activate
    : Setelah instalasi service worker berhasil, siklus hidup selanjutnya ialah
    proses aktivassi. Pada proses ini kita bisa manfaatkan untuk mengelola cache lama.
    Contohnya kita bisa menghapus cache lama bila terdapat penambahan app shell
    atau perubahan versi aplikasi. Hal ini penting, karena bila tidak dilakukan
    cache lama akan menumpuk dan membebani storage browser.

    Sebelum proses aktivasi selesai, Service worker belum dapat mengontrol browser,
    dalam arti ia belum bisa menjalankan tugasnya. Namum perlu diingat untuk proses
    aktivasi Service Worker baru, tak akan langsung dieksekusi bila terdapat service worker
    lama sedang aktif mengontrol browser.  Service worker lama akan berhenti mengontrol
    ketika tab atau browser web ditutup.

    G.3) Idle
    : Setelah service worker berhasil dipasang dan diaktifkan, maka status Service Worker
    akan mengalami idle atau bisa kita sebut bersiap. bersiap untuk melakukan tugas utama
    yaitu mengontrol event fetch, message, atau push yang terjadi pada browser. 

H) Event Pada Service Worker

    H.1) Event Fetch
    : Event fetch akan terpanggil setiap kali sebuah permintaan(request) dilakukan oleh client. 
     Kita dapat mengecek apakah request yang dilakukan sudah terdapat pada Cache API 
     atau belum.

    H.2) Event message
    : Event ini terjadi saat client yang memanggil method postMessage() pada Service Worker
    yang sedang aktif. Event ini dapat kita manfaatkan untuk menerima informasi
    dari client ke Service Worker

    H.3) Event Sync
    : Kita dapat memantau event sync sesuai dengan background sync yang telah kita daftarkan
    di bagian awal proses registrasi service worker. Background sync adalah
    web API yang dapat kita gunakan untuk menunda sebuah aksi sampai perangkat 
    terhubung dengan stabil ke jaringan internet. 

    H.4) Event push
    : Event push diinisiasi oleh backend server dan melewati push service yang ada di browser.
    Service worker dapat memantau setiap event push yang datang ke browser.

I) Cache API
    
    : Tempat penyimpanan lokal yang digunakan browser untuk
    menyimpan resource agar dapat digunakan kembali sehingga
    pada pemanggilan selanjutnya tak perlu mengirim permintaan
    (request) lagi ke jaringan.

    H.1)Mengecek Apakah Browser mendukung cache API

    : const cacheAvailable = 'cache' in self; 

    H.2) Membuat dan Membuka Cache

    : Untuk membuat dan membuka cache, menggunakan
    caches.open(name). Jika cache dengan nama yang ditetapkan
    belum ada ia akan otomatis terbuat. Method open() 
    akan mengembalikan promise yang membawa objek cache pada
    resolves

    caches.open('my-cache')
    .then((cache)=>{

    });

    H.3) Menambahkan Resource Ke Cache

        H.3.1) Cache.add
        
        : cache.add() membutuhkan satu parameter
        bisa sebuah request, atau URL. method ini 
        membuat request dikirimkan ke server dan menyimpan
        response ke cache. Jika request gagal, atau response 
        menghasilkan kode 200, maka tidak ada data yang disimpan
        pada cache

        cache.add(new Request('/data.json'));
        cache.add('data.json');

        H.3.2) Cache.addAll
        
        : Sama seperti add, namun ia dapat memasukkan banyak request
        atau URL String sekaligus. Jika salah satu request gagal, 
        maka tak ada satupun resource yang disimpan. Dan promise
        yang dikembalikan oleh method ini berstatus rejected

        const urls = [/weather/today.json', '/weather/tomorrow.json'];
        cache.addAll(urls);
    
    H.4) Mengambil Resource dari cache

        : Untuk mencari dan mengambil resource dari cache, kita
        gunakan method match

        cache.match(request)
        .then((response)=>{

        });

        Pada method ini, kita dapat menerapkan options di parameter
        kedua. Options digunakan bila kita ingin pencarian cache 
        terhadap request tidak memperdulikan beberapa query,
        parameter, atau attribution lainnya.

        const options = {
            ignoreSearch : true,
            ignoreMethod : true,
            ignoreVary : true,
        };

        cache.match(request, options)
        .then((response)=>{

        });

    H.5) Mencari Cache

    : Untuk menampilkan seluruh nama atau keys yang tersedia
    pada cache, kita dapat menggunakan method keys.

    caches.keys()
    .then((cacheNames)=>{
        cacheNames.forEach((cacheName) =>{
            if(cacheNames !== 'my-cache'){

            }
        })
    })

    H.6) Menghapus Cache

    : Untuk menghapus cache, ita dapat menggunakan method
    caches.delete(). Method tersebut membutuhkan satu parameter
    yakni nama dari cache yang akan dihapus. Biasanya ketika menghapus
    cache kita kombinasikan dengan penggunaan keys.

    cache.keys()
        .then((cacheNames) =>{
            cacheNames.forEach((cacheName) =>{
                if(cacheNames !== 'my-cache'){
                    caches.delete(cacheName)
                }
            })
        })

    H.7) Caching Strategies

        H.7.1) Pola Cache Only

        : Pola cache only merupakan pola caching dimana aplikasi
        hanya mengembalikan aset yang ada di dalam cache, 
        tanpa mengirim request ke jaringan. Cache only 
        cocok digunakan pada aset statis yang jarang berubah
        seperti aset untuk app shell.

        self.addEventListener('fetch', (event) => {
            event.respondWith(caches.match(event.request));
        });

        1.) precaching, menyimpan aset ke dalam cache pada saat
        instalasi service worker. 

        2) halaman melakukan request dan diintercept service worker

        3) service worker mencari cache yang sesuai

        4) cache mengembalikan ke halaman.

        H.7.2) Network Only

        : hanya mengirimkan permintaan ke internet
        tanpa menggunakan penyimpanan cache. Strategi 
        ini cocok diterapkan pada data yang selalu berubah
        dan pengguna harus selalu mendapatkan data terbaru.

        self.addEventListener('fetch', (event)=>{
            event.respondWith(fetch(even.request));
        });

        H.7.2) Cache First(Cache Fallback to network)

        : Request akan diambil dari cache dulu, namun bila request
        tidak ditemukan pada cache, ia akan mengambil resource dari 
        internet.

        self.addEventListener('fetch', (event)=>{
            event.respondWith(
                caches.match(event.request).then((response) =>{
                    return response || fetch(even.request);
                })
            )
        });

        H.7.2) Network First

        : Selalu mengirim request ke internet, bila request berhasil
        response akan dimasukan ke dalam cache. Namun bila request
        gagal ia langsung dialihkan menggunakan cache.

        self.addEventListener('fetch', (event)=>{
            event.respondWith(
                fetch(even.request)
                .catch(()=>{
                    return caches.match(event.request)
                })
            )
        })

        H.7.3) Stale While Revalidate

        : Pada strategi Stale while revalidate kita 
        mengembalikan dulu data dari cache bila ada, 
        sambil mengirim juga permintaan ke jaringan untuk memperbaharui 
        data di dalam cache. Sehingga untuk permintaan selanjutnya,
        data yang diambil dari cache adalah data yang terbaru

        self.addEventListener('fetch', (event)=>{
            event.respondWith(revalidateCache(event.request));
        });

        const revalidateCache = async(request) =>{
            const response = await caches.match(request);
            if(response){
                _fetchRequest(request);
                return response;
            }
            return _fetchRequest(request);
        };

        const _fetchRequest = async (request) => {
            const response = await fetch(request);
            
            if (!response || response.status !== 200) {
                return response;
            }
            _addToCache(request);
            return response;
        };

        const _addToCache = async (request) => {
            const cache = await caches.open(CACHE_NAME);
            cache.add(request);
        };

        

      

        
    